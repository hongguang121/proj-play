#lang racket

(define wlist (future (λ () (stream-first (stream->list (stream (file->string "e:/source/words/wlist.txt")))))))
(define slist (future (λ () (stream-first (stream->list (stream (file->string "e:/source/words/slist.txt")))))))
(define idlist (future (λ () (file->string "e:/source/words/identical.txt"))))
(define article (future (λ () (file->string "e:/source/words/test.txt"))))
(define dict+ (delay (file->lines "e:/source/words/dict.txt")))

(define (pre-load)
  (let ()
    (set! wlist (touch wlist))
    (set! slist (touch slist))
    (set! idlist (touch idlist))
    (set! article (touch article))))

(pre-load)

(define (words/to-string str-ref)
  (list->string (list str-ref)))

(define (format* ls sym)
  (define (select)
    (cond ((eq? 'wlist sym) (iter ls 0 2 '() '()))          
          ((eq? 'vocab sym) (iter ls 0 4 '() '()))
          ((eq? 'slist sym) (fstr ls 0 0 "" '() '()))
          ((eq? 'idlist sym) (idstr ls 0 "" '() '()))))
  (define (iter lt cnt len rem res)
    (cond ((null? lt) (append res (list rem)))
          ((= cnt len) (iter lt 0 len '() (append res (list rem))))
          (else (iter (cdr lt) (+ cnt 1) len (append rem (list (car lt))) res))))
  (define (fstr str cnt line check rem res)
    (cond ((= line 2)
           (fstr str cnt 0 "" '() (cons rem res)))
          ((= (string-length str) cnt) (reverse res))
          ((string=? (words/to-string (string-ref str cnt)) "\r")
           (fstr str (+ cnt 1) line "" (append rem (list check)) res))
          ((string=? (words/to-string (string-ref str cnt)) "\n")
           (fstr str (+ cnt 1) (+ line 1) "" rem res))          
          (else (fstr str (+ cnt 1) line (string-append check (words/to-string (string-ref str cnt))) rem res))))
  (define (idstr str cnt check rem res)
    (cond ((= (string-length str) cnt) (reverse res))
          ((string=? (words/to-string (string-ref str cnt)) "\n")
           (idstr str (+ cnt 1) "" '() (cons (reverse rem) res)))
          ((or (string=? (words/to-string (string-ref str cnt)) "\r")
               (string=? (words/to-string (string-ref str cnt)) "\t")
               (string=? (words/to-string (string-ref str cnt)) " "))
           (idstr str (+ cnt 1) "" (cons check rem) res))
          (else (idstr str (+ cnt 1) (string-append check (words/to-string (string-ref str cnt))) rem res))))
  (select))

(define mywords (format* wlist 'slist))
(define mysets (format* slist 'slist))
(define id (format* idlist 'idlist))

(define (reuse ls path exists)
  (display-lines-to-file ls path #:mode 'text #:exists exists))

(define (add word)
  (if (and (not (assf (λ (x) (string=? (car word) x)) mywords))(= (length word) 2))
      (begin
        (reuse word "e:/source/words/wlist.txt" 'append)
        (set! wlist (file->string "e:/source/words/wlist.txt"))
        (set! mywords (format* wlist 'slist)))
      (assf (λ (x) (string=? (car word) x)) mywords)))

(define (adds sentence)
  (if (not (assf (λ (x) (string=? (car sentence) x)) mysets))
      (begin
        (reuse sentence "e:/source/words/slist.txt" 'append)        
        (set! slist (file->string "e:/source/words/slist.txt"))
        (set! mysets (format* slist 'slist)))
      (assf (λ (x) (string=? (car sentence) x)) mysets)))

(define (change new)
  (let ()
    (del (car new))
    (add new)))

(define (del word)
  (if (assf (λ (x) (string=? word x)) mywords)
      (begin 
        (set! mywords (remove* (list word) mywords (λ (x y) (string=? x (car y)))))
        (delete-file "e:/source/words/wlist.txt")
        (map (λ (x) (reuse x "e:/source/words/wlist.txt" 'append)) mywords)
        (set! wlist (file->string "e:/source/words/wlist.txt"))
        (set! mywords (format* wlist 'slist)))
      "Not Find."))

(define (find-en str)
  (if (string=? str "")
      "请输入要查询的单词"
      (filter (λ (x) (or (string-contains? (car x) (string-downcase str))
                         (string-contains? (string-downcase str) (car x)))) mywords)))

(define (find-cn str)
  (filter (λ (x) (string-contains? (cadr x) str)) mywords))

(define (test name)
  (if (null? name) "全部测试完毕"
      (let* ((ref (random (length name)))
             (word (car (list-ref name ref)))
             (mean (cadr (list-ref name ref))))
        (display word)
        (display " ————> ")
        (let ((rd (read)))
          (cond ((eq? 'n rd)
                 (begin
                   (display mean)
                   (set! name (remove word name))
                   (newline)
                   (test name)))
                (else "测试结束"))))))

(define (index ch)
  (case (char->integer ch)
    ((65 97) (cons 0 4749))((66 98) (cons 4749 10008))((67 99) (cons 10008 18523))((68 100) (cons 18523 23847))
    ((69 101) (cons 23847 26934))((70 102) (cons 26934 31185))((71 103) (cons 31185 34261))((72 104) (cons 34261 37731))
    ((73 105) (cons 37731 41735))((74 106) (cons 41735 42525))((75 107) (cons 42525 43189))((76 108) (cons 43189 46363))
    ((77 109) (cons 46363 51031))((78 110) (cons 51031 52669))((79 111) (cons 52669 54829))((80 112) (cons 54829 62570))
    ((81 113) (cons 62570 63032))((82 114) (cons 63032 67674))((83 115) (cons 67674 78602))((84 116) (cons 78602 83390))
    ((85 117) (cons 83390 85116))((86 118) (cons 85116 86507))((87 119) (cons 86507 89193))((88 120) (cons 89193 89227))
    ((89 121) (cons 89227 89537))((90 122) (cons 89537 89675))))

(define (findm word)
  (let* ((ch (string-ref word 0))
         (start (car (index ch)))
         (end (cdr (index ch))))
    (let loop ((id start))               
      (cond ((= id end) '("not found" "not found"))
            ((regexp-match (regexp (string-append "^" word)) (list-ref (force dict+) id))
             (cons word (list (list-ref (force dict+) (+ id 1)))))
            (else (loop (add1 id)))))))

(define (member? a ls)
  (cond ((null? ls) #f)
        ((member a (car ls)) (car ls))
        (else (member? a (cdr ls)))))

(define (draw str)
  (define (iter cnt check rem)
    (cond ((= (string-length str) cnt) (reverse (cons check rem)))          
          ((regexp-match #rx"[\n|\t|,|.|“|”|(|)|:|;|?|—|%|$|‘|’]"
                         (words/to-string (string-ref str cnt)))           
           (iter (+ cnt 1) check rem))
          ((or (eq? (string-ref str cnt) #\space)
               (string=? (words/to-string (string-ref str cnt)) "\r"))
           (iter (+ cnt 1) "" (cons check rem)))
          (else (iter (+ cnt 1) (string-append check (words/to-string (string-ref str cnt))) rem))))
  (iter 0 "" '()))

(define (id? w1 w2)
  (let* ((w1 (car (draw w1)))
         (w2 (car (draw w2)))
         (len1 (string-length w1))
         (len2 (string-length w2)))   
    (define (iter w1 w2 len1 len2)
      (cond ((member? w1 id)
             (and (member? w2 id)
                  (string=? (car (member? w1 id)) (car (member? w2 id)))))   ;born bear drove drive
            ((and (= (- len1 len2) 1)(> len2 2))
             (and (or (and (regexp-match #rx"s$" w1)
                           (regexp-match #rx"[^s]$" w2))                     ;more mores
                      (and (regexp-match #rx"d$" w1)
                           (regexp-match #rx"e$" w2)))
                  (string-contains? w1 w2)))
            ((and (>= (- len1 len2) 2)(> len2 2)(< (- len1 len2) 5))
             (or (and (regexp-match #rx"s$" w1)
                      (string=? w2 (substring w1 0 (- len1 1))))
                 (and (regexp-match #rx"'s$|'m$" w1)
                      (string=? w2 (substring w1 0 (- len1 2))))
                 (and (regexp-match #rx"ing$" w1)
                      (regexp-match #rx"e$" w2)
                      (string-contains? w2 (substring w1 0 (- len1 3))))
                 (and (regexp-match #rx"ing$" w1)
                      (regexp-match #rx"[d|l|n|t|y]$" w2)                      
                      (string=? w2 (substring w1 0 (- len1 3)))) ;writ writing
                 (and (regexp-match #rx"ning$" w1)
                      (regexp-match #rx"n$" w2)                      
                      (string=? w2 (substring w1 0 (- len1 4))))
                 (and (regexp-match #rx"ly$" w1)
                      (regexp-match #rx"[e|d|g|i|r|s|t|l]$" w2)
                      (string=? w2 (substring w1 0 (- len1 2))))
                 (and (regexp-match #rx"ed$" w1)
                      (string=? w2 (substring w1 0 (- len1 2))))
                 (and (regexp-match #rx"ies$|ied$" w1)
                      (regexp-match #rx"y$" w2)
                      (string-contains? w2 (substring w1 0 (- len1 3))))
                 (and (regexp-match #rx"ity" w1)
                      (string=? w2 (substring w1 0 (- len1 3))))
                 (and (regexp-match #rx"er$|es$" w1)
                      (regexp-match #rx"[g|l]$" w2)
                      (string-contains? w2 (substring w1 0 (- len1 2))))
                 (and (regexp-match #rx"ten$|ted$" w1)
                      (regexp-match #rx"e$" w2)
                      (string-contains? w2 (substring w1 0 (- len1 2))))
                 (and (regexp-match #rx"ring$" w1)                        ;ear earring
                      (string=? w2 (substring w1 0 (- len1 4))))
                 (and (regexp-match #rx"ful$|est$" w1)
                      (regexp-match #rx"g$" w2)
                      (char=? (string-ref w1 0)(string-ref w2 0))
                      (string=? w2 (substring w1 0 (- len1 3))))
                 (and (regexp-match #rx"ion$" w1)
                      (regexp-match #rx"[e|t]$" w2)
                      (string=? w2 (substring w1 0 (- len1 3))))
                 (and (regexp-match #rx"ions$" w1)
                      (regexp-match #rx"[e|t]$" w2)
                      (string-contains? w2 (substring w1 0 (- len1 4))))
                 ))
            (else (string=? w1 w2))))
    (if (string=? w1 w2)
        #t
        (if (>= len1 len2)
            (iter w1 w2 len1 len2)
            (iter w2 w1 len2 len1)))))

(define (b-search key)
  (let ((len (length mywords)))
    (let loop ((curr (floor (/ len 2)))
               (start 0)
               (end len))
      (if (id? (car (list-ref mywords curr)) key)               
          (list-ref mywords curr)
          (cond ((= curr start) #f)
                ((string<? (car (list-ref mywords curr)) key)
                 (loop (floor (/ (+ curr end) 2)) curr end))
                (else (loop (floor (/ (+ start curr) 2)) start curr)))))))

(define (analyse art)
  (let ((lt (string-split art)))
    (let/cc skip 'skip
    (define (iter lt res)
      (let* ((word (if (null? lt)
                       (skip (reverse res))
                       (string-downcase (car lt))))
             (rem (b-search word)))
        (cond ((not (eq? #f rem))
               (iter (cdr lt) (cons (string-append (car lt) "(" (cadr rem) ")") res)))
              (else (iter (cdr lt) (cons (car lt) res))))))
    (iter lt '()))))

(define (dsp ls)
  (define (iter ls res)
    (cond ((null? ls) (string->symbol res))
          (else (iter (cdr ls) (string-append res " " (car ls))))))
  (iter (cdr ls) (car ls)))

(command-line
 #:program "mywords"
 #:once-any
 [("-t") "测试已学词汇，n键继续，其他键退出"
         (test mywords)] 
 #:args (proc1 proc2) 
 (cond ((string=? proc1 "fe")
        (let loop ((res (find-en proc2)))
          (if (null? res)
              (display "")
              (begin
                (printf "~a: ~a~n" (caar res) (cadar res))
                (loop (cdr res))))))
       ((string=? proc1 "fm")
        (let loop ((res (findm proc2)))
          (if (null? res)
              (display "")              
              (printf "~a: ~a~n" (car res) (cadr res)))))                
       ((string=? proc1 "fc")
        (let loop ((res (find-cn proc2)))
          (if (null? res)
              (display "")
              (begin
                (printf "~a: ~a~n" (caar res) (cadar res))
                (loop (cdr res))))))
       ((string=? proc1 "ana")
        (dsp (analyse (file->string proc2))))
       ))

;(system "simple-words fm rampart")