#lang racket

(define (point city x y)
  (define (Cartesian-pt)
    (sqrt (+ (expt x 2) (expt y 2))))
  (define (Manhattan-pt)
    (+ x y))
  (case ((λ () city))
    ((Cartesian-pt) (Cartesian-pt))
    ((Manhattan-pt) (Manhattan-pt))))

(printf "Manhattan-pt's distance: ~a\n" (point 'Manhattan-pt 3 4))
(printf "Cartesian-pt's distance: ~a\n" (point 'Cartesian-pt 3 4))

(define shish-list '(onion lamb tomato))

(define (only-onion shish-list)
  (cond ((null? shish-list) #t)
        ((not (eq? 'onion (car shish-list))) #f)
        (else (only-onion (cdr shish-list)))))

(define meza '(Shrimp Calamari Escargots Hummus))
(define main '(Steak Ravioli Chicken Eggplant))
(define salad '(Green Cucumber Greek))
(define dessert '(Sundae Mousse Torte))

(define menu '(Shrimp Torte Chicken Green Sundae Escargots Eggplant Greek))

(define (add-steak x)
  (cons x '(Steak)))

(add-steak 'Ravioli)

(define (return-type x)  
  (cond ((not (eq? #f (member x meza))) 'meza)
        ((not (eq? #f (member x main))) 'main)
        ((not (eq? #f (member x salad))) 'salad)
        ((not (eq? #f (member x dessert))) 'dessert)
        (else "unknown type")))

;检查ls中是否有T类型，T是该类型的集合
(define (has-type? ls T)
  (cond ((null? ls) #f)
        ((member (car ls) T) #t)
        (else (has-type? (cdr ls) T))))

(define (add-type ls)
  (map (λ (x) (cons x (return-type x))) ls))

(define (check-class ls T)
  (cond ((null? ls) '())
        ((not (member (car ls) T))
         (printf "Type error: ~a\n" (car ls)))
        (else (check-class (cdr ls) T))))

(has-type? '(Shrimp Ravioli Green) dessert)
(has-type? '(Shrimp Ravioli Green) salad)

(map return-type '(Shrimp Ravioli Green))
(check-class '(Shrimp Ravioli Escargots) meza)

;Apple class '(color weight)
(define apple '(("red" 150) ("green" 164) ("red" 135)))

(define (apple-color app)
  (car app))

(define (apple-weight app)
  (cadr app))

(filter (λ (app) (string=? "red" (apple-color app))) apple)
(filter (λ (app) (>= (apple-weight app) 150)) apple)
(sort apple #:key cadr >=)

